{{define "ormCodePgx"}}
{{if .BuildTags}}
//go:build {{.BuildTags}}

{{end}}// Code generated by sqlc. DO NOT EDIT.
{{if not .OmitSqlcVersion}}// versions:
//   sqlc {{.SqlcVersion}}
{{end}}

package {{.Package}}
{{ if hasImports .SourceName }}
import (
	{{range imports .SourceName}}
	{{range .}}{{.}}
	{{end}}
	{{end}}
)
{{end}}

type ORMDB interface {
	Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
	Query(context.Context, string, ...interface{}) (pgx.Rows, error)
	QueryRow(context.Context, string, ...interface{}) pgx.Row
	CopyFrom(ctx context.Context, tableName pgx.Identifier, columnNames []string, rowSrc pgx.CopyFromSource) (int64, error)
}

{{range .Structs}}

type {{.Name}}Update struct { {{- range .Fields}}
  {{- if ne .Name "ID" }}
    {{.Name}} omit.Val[{{.Type}}]
  {{- end}}
  {{- end}}
}

func (u *{{.Name}}Update) updateQuery() (string, []any) {
    args := make([]any, 0)
    cnt := 2
    sqls := make([]string, 0)
    {{- range .Fields}}
    {{- if ne .Name "ID" }}
    if u.{{.Name}}.IsSet() {
        args = append(args,u.{{.Name}}.MustGet())
        cnt++
        sqls = append(sqls, fmt.Sprintf("{{ dbName .Name}}=$%d", cnt))
    }
    {{- end}}
    {{- end}}
    return strings.Join(sqls, ","),args
}

type {{.Name}}ORM struct {
    db ORMDB
}

func New{{.Name}}ORM(db ORMDB) *{{.Name}}ORM{
    return &{{.Name}}ORM{db:db}
}

func (m *{{.Name}}ORM) updateQuery(id string,update *{{.Name}}Update,returning bool) (string, []any) {
    fields,args:=update.updateQuery()
    end:=";"
    if returning {
        end=" RETURNING *;"
    }
    sql := fmt.Sprintf("UPDATE {{ .Table.Name }} SET %s WHERE id = $1%s",fields,end)
    return sql,append([]any{id},args...)
}

func (m *{{.Name}}ORM) scan(scanner interface { Scan(dest ...any) error }) (*{{.Name}},error) {
    var ret *{{.Name}}
    if err := scanner.Scan(
        {{- range .Fields}}
                &ret.{{.Name}},
            {{- end}}
        ); err != nil {
            return nil, err
    }
    return ret, nil
}

const list{{.Name}}Sql = `SELECT
({{- range $i, $f := .Fields}}
 {{- if $i}},{{- end}}
    {{ dbName .Name}}
 {{- end}}
)
FROM {{ .Table.Name }}
WHERE id > $1 LIMIT $2`

func (m *{{.Name}}ORM) Query(ctx context.Context,idOffset string,limit int) ([]*{{.Name}},error){
    rows,err := m.db.Query(ctx,find{{.Name}}Sql,idOffset,limit)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    var items []*{{.Name}}
    for rows.Next() {
        ret,err:= m.scan(rows)
        if err != nil {
            return nil, err
        }
        items = append(items, ret)
    }
    if err := rows.Err(); err != nil {
        return nil, err
    }
    return items, nil
}

const find{{.Name}}Sql = `SELECT
({{- range $i, $f := .Fields}}
 {{- if $i}},{{- end}}
    {{ dbName .Name}}
 {{- end}}
)
FROM {{ .Table.Name }} WHERE id = $1`

func (m *{{.Name}}ORM) Find(ctx context.Context,id string) (*{{.Name}},error){
    return m.scan(m.db.QueryRow(ctx,find{{.Name}}Sql,id))
}

const insert{{.Name}}Sql = `{{.InsertQuery}}`

func (m *{{.Name}}ORM) Insert(ctx context.Context, create *{{.Name}}) (int64, error){
    tag,err:=m.db.Exec(ctx, insert{{.Name}}Sql,
        {{- range .Fields}}
            create.{{.Name}},
        {{- end}}
    )
    return tag.RowsAffected(), err
}

const insertRet{{.Name}}Sql = `{{.InsertReturning}}`

func (m *{{.Name}}ORM) InsertRet(ctx context.Context, create *{{.Name}}) (*{{.Name}},error){
    return m.scan(
    m.db.QueryRow(ctx,insertRet{{.Name}}Sql,
        {{- range .Fields}}
            create.{{.Name}},
        {{- end}}
        ),
    )
}

type iteratorForORM{{.Name}} struct {
	rows []*{{.Name}}
	skippedFirstNextCall bool
}

func (r *iteratorForORM{{.Name}}) Err() error { return nil }

func (r *iteratorForORM{{.Name}}) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r *iteratorForORM{{.Name}}) Values() ([]interface{}, error) {
    return []interface{}{
{{- range .Fields }}
        r.rows[0].{{.Name}},
{{- end }}
    }, nil
}

func (m *{{.Name}}ORM) InsertMany(ctx context.Context, create []*{{.Name}}) (int64, error){
    return m.db.CopyFrom(ctx, []string{"{{.Table.Name}}"}, []string{
        {{- range .Fields}}
            "{{dbName .Name}}",
        {{- end}}
    }, &iteratorForORM{{.Name}}{rows: create})
}

const upsert{{.Name}}Sql = `{{.UpsertQuery}}`

func (m *{{.Name}}ORM) Upsert(ctx context.Context, create *{{.Name}}) (int64,error){
    tag,err:=m.db.Exec(ctx, upsert{{.Name}}Sql,
        {{- range .Fields}}
            create.{{.Name}},
        {{- end}}
    )
    return tag.RowsAffected(), err
}

const upsertRet{{.Name}}Sql = `{{.UpsertReturning}}`

func (m *{{.Name}}ORM) UpsertRet(ctx context.Context, create *{{.Name}}) (*{{.Name}},error){
    return m.scan(
    m.db.QueryRow(ctx,upsertRet{{.Name}}Sql,
        {{- range .Fields}}
            create.{{.Name}},
        {{- end}}
        ),
    )
}

var ErrUpdate{{.Name}}IsNil = errors.New("{{.Name}} update struct is nil")

func (m *{{.Name}}ORM) Update(ctx context.Context,id string, update *{{.Name}}Update) (int64, error){
    if update==nil{
        return 0, ErrUpdate{{.Name}}IsNil
    }
    q,args:=m.updateQuery(id,update,false)
    tag,err:= m.db.Exec(ctx, q,args...)
    if err != nil {
        return 0, err
    }
    return tag.RowsAffected(), nil
}

func (m *{{.Name}}ORM) UpdateRet(ctx context.Context, id string, update *{{.Name}}Update) (*{{.Name}},error){
    if update==nil{
        return nil,ErrUpdate{{.Name}}IsNil
    }
    q,args:=m.updateQuery(id,update,false)
    return m.scan(m.db.QueryRow(ctx, q, args...))
}

const delete{{.Name}}Sql = "DELETE FROM {{ .Table.Name }} WHERE id = $1"

func (m *{{.Name}}ORM) Delete(ctx context.Context,id string) (int64,error){
    tag,err:=m.db.Exec(ctx,delete{{.Name}}Sql,id)
    return tag.RowsAffected(), err
}

const deleteRet{{.Name}}Sql = "DELETE FROM {{ .Table.Name }} WHERE id = $1 RETURNING *"

func (m *{{.Name}}ORM) DeleteRet(ctx context.Context,id string) (*{{.Name}},error){
    return m.scan(m.db.QueryRow(ctx,deleteRet{{.Name}}Sql,id))
}

{{end}}
{{end}}