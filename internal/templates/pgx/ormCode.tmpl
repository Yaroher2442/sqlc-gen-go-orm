{{define "ormCodePgx"}}
{{if .BuildTags}}
//go:build {{.BuildTags}}

{{end}}// Code generated by sqlc. DO NOT EDIT.
{{if not .OmitSqlcVersion}}// versions:
//   sqlc {{.SqlcVersion}}
{{end}}

package {{.Package}}
{{ if hasImports .SourceName }}
import (
	{{range imports .SourceName}}
	{{range .}}{{.}}
	{{end}}
	{{end}}
)
{{end}}

type ORMDB interface {
	Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
	Query(context.Context, string, ...interface{}) (pgx.Rows, error)
	QueryRow(context.Context, string, ...interface{}) pgx.Row
	CopyFrom(ctx context.Context, tableName pgx.Identifier, columnNames []string, rowSrc pgx.CopyFromSource) (int64, error)
}

type Orm struct {
    {{range .Structs}}
    {{- .Name}} *{{.Name}}Orm
    {{end}}
}

func NewOrm(db ORMDB) *Orm {
    return &Orm{
        {{range .Structs}}
        {{- .Name}}: New{{.Name}}Orm(db),
        {{end}}
    }
}

{{range .Structs}}
{{$Struct:= .}}



type {{.Name}}Orm struct {
    db ORMDB
}


func New{{.Name}}Orm(db ORMDB) *{{.Name}}Orm{
    return &{{.Name}}Orm{db:db}
}

func (m *{{.Name}}Orm) scan(scanner interface { Scan(dest ...any) error }) (*{{.Name}},error) {
    var ret *{{.Name}}
    if err := scanner.Scan(
        {{- range .Fields}}
                &ret.{{.Name}},
            {{- end}}
        ); err != nil {
            return nil, err
    }
    return ret, nil
}

func (q *{{lowerTitle .Name}}QB) build() (string, []any) {
    clauses := make([]string, 0)
    args := make([]any, 0)
    {{- range .Fields}}
    if q.{{.Name}}.IsSet() {
        clauses = append(clauses, fmt.Sprintf("{{ dbName .Name}}=$%d", len(args)+1))
        args = append(args, q.{{.Name}}.MustGet())
    }
    {{- end}}
    fields := []string{
        {{- range .Fields}}"{{ dbName .Name}}",{{- end}}
    }
    return fmt.Sprintf("SELECT %s FROM {{ .Table.Name }} WHERE %s",
        strings.Join(fields, ", "),
        strings.Join(clauses, " AND "),
    ), args
}



{{- if .HasPk }}
type {{.Name}}Update struct { {{- range .Fields}}
  {{- if ne .Name "ID" }}
    {{.Name}} omit.Val[{{.Type}}]
  {{- end}}
  {{- end}}
}

func (u *{{.Name}}Update) updateQuery() (string, []any) {
    args := make([]any, 0)
    cnt := 2
    sqls := make([]string, 0)
    {{- range .Fields}}
    {{- if ne .Name "ID" }}
    if u.{{.Name}}.IsSet() {
        args = append(args,u.{{.Name}}.MustGet())
        cnt++
        sqls = append(sqls, fmt.Sprintf("{{ dbName .Name}}=$%d", cnt))
    }
    {{- end}}
    {{- end}}
    return strings.Join(sqls, ","),args
}

func (m *{{.Name}}Orm) updateQuery(id string,update *{{.Name}}Update,returning bool) (string, []any) {
    fields,args:=update.updateQuery()
    end:=";"
    if returning {
        end=" RETURNING *;"
    }
    sql := fmt.Sprintf("UPDATE {{ .Table.Name }} SET %s WHERE id = $1%s",fields,end)
    return sql,append([]any{id},args...)
}

const list{{.Name}}Sql = `SELECT
({{- range $i, $f := .Fields}}
 {{- if $i}},{{- end}}
    {{ dbName .Name}}
 {{- end}}
)
FROM {{ .Table.Name }}
WHERE id > $1 LIMIT $2`

func (m *{{.Name}}Orm) List(ctx context.Context,idOffset string,limit int) ([]*{{.Name}},error){
    rows,err := m.db.Query(ctx,find{{.Name}}Sql,idOffset,limit)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    var items []*{{.Name}}
    for rows.Next() {
        ret,err:= m.scan(rows)
        if err != nil {
            return nil, err
        }
        items = append(items, ret)
    }
    if err := rows.Err(); err != nil {
        return nil, err
    }
    return items, nil
}

const find{{.Name}}Sql = `SELECT
({{- range $i, $f := .Fields}}
 {{- if $i}},{{- end}}
    {{ dbName .Name}}
 {{- end}}
)
FROM {{ .Table.Name }} WHERE id = $1`

func (m *{{.Name}}Orm) Find(ctx context.Context,id string) (*{{.Name}},error){
    return m.scan(m.db.QueryRow(ctx,find{{.Name}}Sql,id))
}
{{- end}}
const insert{{.Name}}Sql = `{{.InsertQuery}}`

func (m *{{.Name}}Orm) Insert(ctx context.Context, create *{{.Name}}) (int64, error){
    tag,err:=m.db.Exec(ctx, insert{{.Name}}Sql,
        {{- range .Fields}}
            create.{{.Name}},
        {{- end}}
    )
    return tag.RowsAffected(), err
}

const insertRet{{.Name}}Sql = `{{.InsertReturning}}`

func (m *{{.Name}}Orm) InsertRet(ctx context.Context, create *{{.Name}}) (*{{.Name}},error){
    return m.scan(
    m.db.QueryRow(ctx,insertRet{{.Name}}Sql,
        {{- range .Fields}}
            create.{{.Name}},
        {{- end}}
        ),
    )
}

type iteratorForORM{{.Name}} struct {
	rows []*{{.Name}}
	skippedFirstNextCall bool
}

func (r *iteratorForORM{{.Name}}) Err() error { return nil }

func (r *iteratorForORM{{.Name}}) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r *iteratorForORM{{.Name}}) Values() ([]interface{}, error) {
    return []interface{}{
{{- range .Fields }}
        r.rows[0].{{.Name}},
{{- end }}
    }, nil
}

func (m *{{.Name}}Orm) InsertMany(ctx context.Context, create []*{{.Name}}) (int64, error){
    return m.db.CopyFrom(ctx, []string{"{{.Table.Name}}"}, []string{
        {{- range .Fields}}
            "{{dbName .Name}}",
        {{- end}}
    }, &iteratorForORM{{.Name}}{rows: create})
}

const upsert{{.Name}}Sql = `{{.UpsertQuery}}`

func (m *{{.Name}}Orm) Upsert(ctx context.Context, create *{{.Name}}) (int64,error){
    tag,err:=m.db.Exec(ctx, upsert{{.Name}}Sql,
        {{- range .Fields}}
            create.{{.Name}},
        {{- end}}
    )
    return tag.RowsAffected(), err
}

const upsertRet{{.Name}}Sql = `{{.UpsertReturning}}`

func (m *{{.Name}}Orm) UpsertRet(ctx context.Context, create *{{.Name}}) (*{{.Name}},error){
    return m.scan(
    m.db.QueryRow(ctx,upsertRet{{.Name}}Sql,
        {{- range .Fields}}
            create.{{.Name}},
        {{- end}}
        ),
    )
}

var ErrUpdate{{.Name}}IsNil = errors.New("{{.Name}} update struct is nil")
{{- if .HasPk }}
func (m *{{.Name}}Orm) Update(ctx context.Context,id string, update *{{.Name}}Update) (int64, error){
    if update==nil{
        return 0, ErrUpdate{{.Name}}IsNil
    }
    q,args:=m.updateQuery(id,update,false)
    tag,err:= m.db.Exec(ctx, q,args...)
    if err != nil {
        return 0, err
    }
    return tag.RowsAffected(), nil
}

func (m *{{.Name}}Orm) UpdateRet(ctx context.Context, id string, update *{{.Name}}Update) (*{{.Name}},error){
    if update==nil{
        return nil,ErrUpdate{{.Name}}IsNil
    }
    q,args:=m.updateQuery(id,update,false)
    return m.scan(m.db.QueryRow(ctx, q, args...))
}


const delete{{.Name}}Sql = "DELETE FROM {{ .Table.Name }} WHERE id = $1"

func (m *{{.Name}}Orm) Delete(ctx context.Context,id string) (int64,error){
    tag,err:=m.db.Exec(ctx,delete{{.Name}}Sql,id)
    return tag.RowsAffected(), err
}

const deleteRet{{.Name}}Sql = "DELETE FROM {{ .Table.Name }} WHERE id = $1 RETURNING *"

func (m *{{.Name}}Orm) DeleteRet(ctx context.Context,id string) (*{{.Name}},error){
    return m.scan(m.db.QueryRow(ctx,deleteRet{{.Name}}Sql,id))
}
{{- end}}

{{end}}
{{end}}